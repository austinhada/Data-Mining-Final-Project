healthExpBudget_complete <- healthExpBudget_complete[complete.cases(healthExpBudget_complete),]
# Row numbers that have NA in the healthExpBudget column
naRow_healthExpBudget <- !complete.cases(dat_numeric[,"percent.expenditure"])
# Grab rows with NA in the healthExpBudget columns
healthExpBudget_incomplete <- dat_numeric[naRow_healthExpBudget,]
# Getting rid of Columns with NA
healthExpBudget_incomplete <- healthExpBudget_incomplete[,colSums(!is.na(healthExpBudget_incomplete))==nrow(healthExpBudget_incomplete)]
# Removing the NA healthExpBudget rows, and choosing the columns that are complete
# for the above dataset
healthExpBudget_complete <- dat_numeric[!naRow_healthExpBudget,                       # Row
c("percent.expenditure",names(healthExpBudget_incomplete))]  # Col
# Getting only the complete rows
healthExpBudget_complete <- healthExpBudget_complete[complete.cases(healthExpBudget_complete),]
# Row numbers that have NA in the percent.expenditure column
naRow_healthExpBudget <- !complete.cases(dat_numeric[,"percent.expenditure"])
# Grab rows with NA in the percent.expenditure columns
healthExpBudget_incomplete <- dat_numeric[naRow_healthExpBudget,]
# Getting rid of Columns with NA
healthExpBudget_incomplete <- healthExpBudget_incomplete[,colSums(!is.na(healthExpBudget_incomplete))==nrow(healthExpBudget_incomplete)]
# Removing the NA healthExpBudget rows, and choosing the columns that are complete
# for the above dataset
healthExpBudget_complete <- dat_numeric[!naRow_healthExpBudget,                       # Row
c("percent.expenditure",names(healthExpBudget_incomplete))]  # Col
# Getting only the complete rows
healthExpBudget_complete <- healthExpBudget_complete[complete.cases(healthExpBudget_complete),]
# Row numbers that have NA in the percent.expenditure column
naRow_healthExpBudget <- !complete.cases(dat_numeric[,"percent.expenditure"])
# Grab rows with NA in the percent.expenditure columns
healthExpBudget_incomplete <- dat_numeric[naRow_healthExpBudget,]
# Getting rid of Columns with NA
healthExpBudget_incomplete <- healthExpBudget_incomplete[,colSums(!is.na(healthExpBudget_incomplete))==nrow(healthExpBudget_incomplete)]
# Row numbers that have NA in the percent.expenditure column
naRow_healthExpBudget <- !complete.cases(dat_numeric[,"percent.expenditure"])
# Grab rows with NA in the percent.expenditure columns
healthExpBudget_incomplete <- dat_numeric[naRow_healthExpBudget,]
# Getting rid of Columns with NA
healthExpBudget_incomplete <- healthExpBudget_incomplete[,colSums(!is.na(healthExpBudget_incomplete))==nrow(healthExpBudget_incomplete)]
# Removing the NA healthExpBudget rows, and choosing the columns that are complete
# for the above dataset
healthExpBudget_complete <- dat_numeric[!naRow_healthExpBudget,                       # Row
c("percent.expenditure",names(healthExpBudget_incomplete))]  # Col
# Getting only the complete rows
healthExpBudget_complete <- healthExpBudget_complete[complete.cases(healthExpBudget_complete),]
scaled_healthExpBudget_comp <- scale(healthExpBudget_complete[,-1])
healthExpBudget_Attributes <- attributes(scaled_healthExpBudget_comp)
scaled_healthExpBudget_incomp <- scale(healthExpBudget_incomplete,
center = healthExpBudget_Attributes$`scaled:center`,
scale = healthExpBudget_Attributes$`scaled:scale`)
# Setting up LOOCV
train_control <- trainControl(method = "LOOCV")
# Setting up LOOCV
train_control <- trainControl(method = "LOOCV")
# Data mining k
loocv_healthExpBudget <- train(HALE_Birth ~ .,
data = scaled_healthExpBudget_comp,
method = "knn",
trControl = train_control,
preProcess = c("center","scale"),
tuneGrid = data.frame(k=1:11))   #there are 11 regressors
# Data mining k
loocv_healthExpBudget <- train(HALE_Birth ~ .,
data = scaled_healthExpBudget_comp,
method = "knn",
trControl = train_control,
preProcess = c("center","scale"),
tuneGrid = data.frame(k=1:11))   #there are 11 regressors
plot(loocv_healthExpBudget)
# Getting the optimized k nearest neighbors
healthExpBudget_nn <- get.knnx(scaled_healthExpBudget_comp,
scaled_healthExpBudget_incomp,
k=4)
healthExpBudget_index <- healthExpBudget_nn$nn.index
healthExpBudget_complete$percent.expenditure[healthExpBudget_index] %>%
matrix(ncol = 4, byrow = T)
# Row numbers that have NA in the total.expenditure column
naRow_healthExpGDP <- !complete.cases(dat_numeric[,"total.expenditure"])
# Grab rows with NA in the total.expenditure columns
healthExpGDP_incomplete <- dat_numeric[naRow_healthExpGDP,]
# Getting rid of Columns with NA
healthExpGDP_incomplete <- healthExpGDP_incomplete[,colSums(!is.na(healthExpGDP_incomplete))==nrow(healthExpGDP_incomplete)]
# Removing the NA healthExpGDP rows, and choosing the columns that are complete
# for the above dataset
healthExpGDP_complete <- dat_numeric[!naRow_healthExpGDP,                       # Row
c("total.expenditure",names(healthExpGDP_incomplete))]  # Col
# Getting only the complete rows
healthExpGDP_complete <- healthExpGDP_complete[complete.cases(healthExpGDP_complete),]
scaled_healthExpGDP_comp <- scale(healthExpGDP_complete[,-1])
healthExpGDP_Attributes <- attributes(scaled_healthExpGDP_comp)
scaled_healthExpGDP_incomp <- scale(healthExpGDP_incomplete,
center = healthExpGDP_Attributes$`scaled:center`,
scale = healthExpGDP_Attributes$`scaled:scale`)
# Setting up LOOCV
train_control <- trainControl(method = "LOOCV")
# Data mining k
loocv_healthExpGDP <- train(HALE_Birth ~ .,
data = scaled_healthExpGDP_comp,
method = "knn",
trControl = train_control,
preProcess = c("center","scale"),
tuneGrid = data.frame(k=1:11))   #there are 11 regressors
plot(loocv_healthExpGDP)
plot(loocv_healthExpBudget)
# Row numbers that have NA in the total.expenditure column
naRow_healthExpGDP <- !complete.cases(dat_numeric[,"total.expenditure"])
# Grab rows with NA in the total.expenditure columns
healthExpGDP_incomplete <- dat_numeric[naRow_healthExpGDP,]
# Getting rid of Columns with NA
healthExpGDP_incomplete <- healthExpGDP_incomplete[,colSums(!is.na(healthExpGDP_incomplete))==nrow(healthExpGDP_incomplete)]
# Removing the NA healthExpGDP rows, and choosing the columns that are complete
# for the above dataset
healthExpGDP_complete <- dat_numeric[!naRow_healthExpGDP,                       # Row
c("total.expenditure",names(healthExpGDP_incomplete))]  # Col
# Getting only the complete rows
healthExpGDP_complete <- healthExpGDP_complete[complete.cases(healthExpGDP_complete),]
# Getting the optimized k nearest neighbors
healthExpGDP_nn <- get.knnx(scaled_healthExpGDP_comp, scaled_healthExpGDP_incomp, k=4)
healthExpGDP_index <- healthExpGDP_nn$nn.index
healthExpGDP_complete$total.expenditure[healthExpGDP_index] %>% matrix(ncol = 4, byrow = T)
dat
healthExpGDP_complete$total.expenditure[healthExpGDP_index] %>%
matrix(ncol = 4, byrow = T) -> healthGDPmatrix
rowMeans(healthGDPmatrix)
imputed_dat$total.expenditure[naRow_healthExpGDP ,]
imputed_dat$total.expenditure[naRow_healthExpGDP]
imputed_dat$total.expenditure[naRow_healthExpGDP] <- c(1,NA, 4)
imputed_dat$total.expenditure[naRow_healthExpGDP]
healthExpGDP_complete$total.expenditure[healthExpGDP_index] %>%
matrix(ncol = 4, byrow = T) %>%
rowMeans() -> imputed_dat$total.expenditure[naRow_healthExpGDP]
imputed_dat$total.expenditure[naRow_healthExpGDP]
rowMeans(healthGDPmatrix)
# Setting up LOOCV
train_control <- trainControl(method = "LOOCV")
# Data mining k
loocv_healthExpBudget <- train(HALE_Birth ~ .,
data = scaled_healthExpBudget_comp,
method = "knn",
trControl = train_control,
preProcess = c("center","scale"),
tuneGrid = data.frame(k=1:11))   #there are 11 regressors
plot(loocv_healthExpBudget)
# Getting the optimized k nearest neighbors
healthExpBudget_nn <- get.knnx(scaled_healthExpBudget_comp,
scaled_healthExpBudget_incomp,
k=4)
healthExpBudget_index <- healthExpBudget_nn$nn.index
healthExpBudget_complete$percent.expenditure[healthExpBudget_index] %>%
matrix(ncol = 4, byrow = T) %>%
rowMeans() -> imputed_dat$percent.expenditure[naRow_healthExpBudget]
imputed_dat$percent.expenditure[naRow_healthExpBudget]
measlesCases_complete$Measles[measlesCases_index] %>%
matrix(ncol = 3, byrow = T) %>%
rowMeans() -> imputed_dat$Measles[naRow_measlesCases]
# Row numbers that have NA in the measlesCases column
naRow_measlesCases <- !complete.cases(dat_numeric[,"Measles"])
# Grab rows with NA in the measlesCases columns
measlesCases_incomplete <- dat_numeric[naRow_measlesCases,]
# Getting rid of Columns with NA
measlesCases_incomplete <- measlesCases_incomplete[,colSums(!is.na(measlesCases_incomplete))==nrow(measlesCases_incomplete)]
# Removing the NA measlesCases rows, and choosing the columns that are complete
# for the above dataset
measlesCases_complete <- dat_numeric[!naRow_measlesCases,                       # Row
c("Measles",names(measlesCases_incomplete))]  # Col
# Getting only the complete rows
measlesCases_complete <- measlesCases_complete[complete.cases(measlesCases_complete),]
scaled_measlesCases_comp <- scale(measlesCases_complete[,-1])
measlesCases_Attributes <- attributes(scaled_measlesCases_comp)
scaled_measlesCases_incomp <- scale(measlesCases_incomplete,
center = measlesCases_Attributes$`scaled:center`,
scale = measlesCases_Attributes$`scaled:scale`)
# Getting the optimized k nearest neighbors
measlesCases_nn <- get.knnx(scaled_measlesCases_comp, scaled_measlesCases_incomp, k=3)
measlesCases_index <- measlesCases_nn$nn.index
measlesCases_complete$Measles[measlesCases_index] %>%
matrix(ncol = 3, byrow = T) %>%
rowMeans() -> imputed_dat$Measles[naRow_measlesCases]
imputed_dat$Measles[naRow_measlesCases]
infantMortality_complete$infant_mortality[infantMortality_index] %>%
matrix(ncol = 3, byrow = T) %>%
rowMeans() -> imputed_dat$infant_mortality[naRow_infantMortality]
HepB_complete$HepB[HepB_index] %>%
matrix(ncol = 2, byrow = T) %>%
rowMeans() -> imputed_dat$HepB[naRow_HepB]
knitr::opts_chunk$set(echo = TRUE)
library(caret)
library(FNN)
library(dplyr)
dat <- read.csv("C:/Users/hadamul/OneDrive/Graduate school/Semester 4/Data Mining/Data-Mining-Final-Project/life14updated.csv")
dat_numeric <- select(dat, -Country)
imputed_dat <- dat
apply(dat_numeric, 2, function(i)sum(is.na(i)))
summary(dat)
na_columns <- colSums(is.na(dat))
na_columns[na_columns >0]
# Row numbers that have NA in the HepB column
naRow_HepB <- !complete.cases(dat_numeric[,"HepB"])
# Grab rows with NA in the HepB columns
HepB_incomplete <- dat_numeric[naRow_HepB,]
# Getting rid of Columns with NA
HepB_incomplete <- HepB_incomplete[,colSums(!is.na(HepB_incomplete))==nrow(HepB_incomplete)]
# Removing the NA HepB rows, and choosing the columns that are complete
# for the above dataset
HepB_complete <- dat_numeric[!naRow_HepB,                       # Row
c("HepB",names(HepB_incomplete))]  # Col
# Getting only the complete rows
HepB_complete <- HepB_complete[complete.cases(HepB_complete),]
scaled_HepB_comp <- scale(HepB_complete[,-1])
HepB_Attributes <- attributes(scaled_HepB_comp)
scaled_HepB_incomp <- scale(HepB_incomplete,
center = HepB_Attributes$`scaled:center`,
scale = HepB_Attributes$`scaled:scale`)
# Setting up LOOCV
train_control <- trainControl(method = "LOOCV")
# # Data mining k
# loocv_HepB <- train(HALE_Birth ~ .,
#                     data = scaled_HepB_comp,
#                     method = "knn",
#                     trControl = train_control,
#                     preProcess = c("center","scale"),
#                     tuneGrid = data.frame(k=1:12))   #there are 12 regressors
#
# plot(loocv_HepB)
# Getting the optimized k nearest neighbors
HepB_nn <- get.knnx(scaled_HepB_comp, scaled_HepB_incomp, k=2)
HepB_index <- HepB_nn$nn.index
HepB_complete$HepB[HepB_index] %>%
matrix(ncol = 2, byrow = T) %>%
rowMeans() -> imputed_dat$HepB[naRow_HepB]
# Row numbers that have NA in the infantMortality column
naRow_infantMortality <- !complete.cases(dat_numeric[,"infant_mortality"])
# Grab rows with NA in the infantMortality columns
infantMortality_incomplete <- dat_numeric[naRow_infantMortality,]
# Getting rid of Columns with NA
infantMortality_incomplete <- infantMortality_incomplete[,colSums(!is.na(infantMortality_incomplete))==nrow(infantMortality_incomplete)]
# Removing the NA infantMortality rows, and choosing the columns that are complete
# for the above dataset
infantMortality_complete <- dat_numeric[!naRow_infantMortality,                       # Row
c("infant_mortality",names(infantMortality_incomplete))]  # Col
# Getting only the complete rows
infantMortality_complete <- infantMortality_complete[complete.cases(infantMortality_complete),]
scaled_infantMortality_comp <- scale(infantMortality_complete[,-1])
infantMortality_Attributes <- attributes(scaled_infantMortality_comp)
scaled_infantMortality_incomp <- scale(infantMortality_incomplete,
center = infantMortality_Attributes$`scaled:center`,
scale = infantMortality_Attributes$`scaled:scale`)
# Setting up LOOCV
train_control <- trainControl(method = "LOOCV")
# # Data mining k
# loocv_infantMortality <- train(HALE_Birth ~ .,
#                     data = scaled_infantMortality_comp,
#                     method = "knn",
#                     trControl = train_control,
#                     preProcess = c("center","scale"),
#                     tuneGrid = data.frame(k=1:11))   #there are 11 regressors
#
# plot(loocv_infantMortality)
# Getting the optimized k nearest neighbors
infantMortality_nn <- get.knnx(scaled_infantMortality_comp, scaled_infantMortality_incomp, k=3)
infantMortality_index <- infantMortality_nn$nn.index
infantMortality_complete$infant_mortality[infantMortality_index] %>%
matrix(ncol = 3, byrow = T) %>%
rowMeans() -> imputed_dat$infant_mortality[naRow_infantMortality]
# Row numbers that have NA in the measlesCases column
naRow_measlesCases <- !complete.cases(dat_numeric[,"Measles"])
# Grab rows with NA in the measlesCases columns
measlesCases_incomplete <- dat_numeric[naRow_measlesCases,]
# Getting rid of Columns with NA
measlesCases_incomplete <- measlesCases_incomplete[,colSums(!is.na(measlesCases_incomplete))==nrow(measlesCases_incomplete)]
# Removing the NA measlesCases rows, and choosing the columns that are complete
# for the above dataset
measlesCases_complete <- dat_numeric[!naRow_measlesCases,                       # Row
c("Measles",names(measlesCases_incomplete))]  # Col
# Getting only the complete rows
measlesCases_complete <- measlesCases_complete[complete.cases(measlesCases_complete),]
scaled_measlesCases_comp <- scale(measlesCases_complete[,-1])
measlesCases_Attributes <- attributes(scaled_measlesCases_comp)
scaled_measlesCases_incomp <- scale(measlesCases_incomplete,
center = measlesCases_Attributes$`scaled:center`,
scale = measlesCases_Attributes$`scaled:scale`)
# Setting up LOOCV
train_control <- trainControl(method = "LOOCV")
# # Data mining k
# loocv_measlesCases <- train(HALE_Birth ~ .,
#                     data = scaled_measlesCases_comp,
#                     method = "knn",
#                     trControl = train_control,
#                     preProcess = c("center","scale"),
#                     tuneGrid = data.frame(k=1:11))   #there are 11 regressors
#
# plot(loocv_measlesCases)
# Getting the optimized k nearest neighbors
measlesCases_nn <- get.knnx(scaled_measlesCases_comp, scaled_measlesCases_incomp, k=3)
measlesCases_index <- measlesCases_nn$nn.index
measlesCases_complete$Measles[measlesCases_index] %>%
matrix(ncol = 3, byrow = T) %>%
rowMeans() -> imputed_dat$Measles[naRow_measlesCases]
# Row numbers that have NA in the percent.expenditure column
naRow_healthExpBudget <- !complete.cases(dat_numeric[,"percent.expenditure"])
# Grab rows with NA in the percent.expenditure columns
healthExpBudget_incomplete <- dat_numeric[naRow_healthExpBudget,]
# Getting rid of Columns with NA
healthExpBudget_incomplete <- healthExpBudget_incomplete[,colSums(!is.na(healthExpBudget_incomplete))==nrow(healthExpBudget_incomplete)]
# Removing the NA healthExpBudget rows, and choosing the columns that are complete
# for the above dataset
healthExpBudget_complete <- dat_numeric[!naRow_healthExpBudget,                       # Row
c("percent.expenditure",names(healthExpBudget_incomplete))]  # Col
# Getting only the complete rows
healthExpBudget_complete <- healthExpBudget_complete[complete.cases(healthExpBudget_complete),]
scaled_healthExpBudget_comp <- scale(healthExpBudget_complete[,-1])
healthExpBudget_Attributes <- attributes(scaled_healthExpBudget_comp)
scaled_healthExpBudget_incomp <- scale(healthExpBudget_incomplete,
center = healthExpBudget_Attributes$`scaled:center`,
scale = healthExpBudget_Attributes$`scaled:scale`)
# Setting up LOOCV
train_control <- trainControl(method = "LOOCV")
# # Data mining k
# loocv_healthExpBudget <- train(HALE_Birth ~ .,
#                     data = scaled_healthExpBudget_comp,
#                     method = "knn",
#                     trControl = train_control,
#                     preProcess = c("center","scale"),
#                     tuneGrid = data.frame(k=1:11))   #there are 11 regressors
#
# plot(loocv_healthExpBudget)
# Getting the optimized k nearest neighbors
healthExpBudget_nn <- get.knnx(scaled_healthExpBudget_comp,
scaled_healthExpBudget_incomp,
k=4)
healthExpBudget_index <- healthExpBudget_nn$nn.index
healthExpBudget_complete$percent.expenditure[healthExpBudget_index] %>%
matrix(ncol = 4, byrow = T) %>%
rowMeans() -> imputed_dat$percent.expenditure[naRow_healthExpBudget]
# Row numbers that have NA in the total.expenditure column
naRow_healthExpGDP <- !complete.cases(dat_numeric[,"total.expenditure"])
# Grab rows with NA in the total.expenditure columns
healthExpGDP_incomplete <- dat_numeric[naRow_healthExpGDP,]
# Getting rid of Columns with NA
healthExpGDP_incomplete <- healthExpGDP_incomplete[,colSums(!is.na(healthExpGDP_incomplete))==nrow(healthExpGDP_incomplete)]
# Removing the NA healthExpGDP rows, and choosing the columns that are complete
# for the above dataset
healthExpGDP_complete <- dat_numeric[!naRow_healthExpGDP,                       # Row
c("total.expenditure",names(healthExpGDP_incomplete))]  # Col
# Getting only the complete rows
healthExpGDP_complete <- healthExpGDP_complete[complete.cases(healthExpGDP_complete),]
scaled_healthExpGDP_comp <- scale(healthExpGDP_complete[,-1])
healthExpGDP_Attributes <- attributes(scaled_healthExpGDP_comp)
scaled_healthExpGDP_incomp <- scale(healthExpGDP_incomplete,
center = healthExpGDP_Attributes$`scaled:center`,
scale = healthExpGDP_Attributes$`scaled:scale`)
# Setting up LOOCV
train_control <- trainControl(method = "LOOCV")
# # Data mining k
# loocv_healthExpGDP <- train(HALE_Birth ~ .,
#                     data = scaled_healthExpGDP_comp,
#                     method = "knn",
#                     trControl = train_control,
#                     preProcess = c("center","scale"),
#                     tuneGrid = data.frame(k=1:11))   #there are 11 regressors
#
# plot(loocv_healthExpGDP)
# Getting the optimized k nearest neighbors
healthExpGDP_nn <- get.knnx(scaled_healthExpGDP_comp, scaled_healthExpGDP_incomp, k=4)
healthExpGDP_index <- healthExpGDP_nn$nn.index
healthExpGDP_complete$total.expenditure[healthExpGDP_index] %>%
matrix(ncol = 4, byrow = T) %>%
rowMeans() -> imputed_dat$total.expenditure[naRow_healthExpGDP]
View(imputed_dat)
getwd
getwd()
write.csv(imputed_dat, file = "C:/Users/hadamul/OneDrive/Graduate school/Semester 4/Data Mining/Data-Mining-Final-Project/imputedData.csv")
write.csv(imputed_dat, file = "C:/Users/hadamul/OneDrive/Graduate school/Semester 4/Data Mining/Data-Mining-Final-Project/imputedData.csv")
write.csv(imputed_dat, file = "C:/Users/hadamul/OneDrive/Graduate school/Semester 4/Data Mining/Data-Mining-Final-Project/imputedData.csv", row.names = F)
write.csv(imputed_dat, file = "C:/Users/hadamul/OneDrive/Graduate school/Semester 4/Data Mining/Data-Mining-Final-Project/imputedData.csv", row.names = F)
knitr::opts_chunk$set(echo = TRUE)
library(sampling)
library(tidyverse)
library(rworldmap)
library(mclust)
dat <- read.csv("C:/Users/hadamul/OneDrive/Graduate school/Semester 4/Data Mining/Data-Mining-Final-Project/imputedData.csv")
knitr::opts_chunk$set(echo = TRUE)
library(sampling)
library(tidyverse)
library(rworldmap)
library(mclust)
dat <- read.csv("C:/Users/hadamul/OneDrive/Graduate school/Semester 4/Data Mining/Data-Mining-Final-Project/imputedData.csv")
dat_scaled <- scale(dat)
dat_scaled <- scale(dat[,-1])
RNGkind (sample.kind = "Rounding")
set.seed(0)
nseeds <- 1000
nk <- 20
seeds <- ceiling(runif(nseeds,0,900000))
kmean_matrix  <- matrix(NA, nrow = nseeds, ncol = nk)
for (k in 1:nk) {
seed_iter = 0
for (s in seeds) {
set.seed(s)
seed_iter <- seed_iter + 1
kmean_matrix[seed_iter,k] <- kmeans(dat_scaled, centers = k)$tot.withinss
}
}
save(kmean_matrix, file = "kmean_matrix.RData")
load("kmean_matrix.RData")
plot(1:nk,apply(kmean_matrix, 2, min),
type = "b",
ylab = "wss",
xlab = "k")
plot(1:nk,apply(kmean_matrix, 2, min),
type = "l",
ylab = "wss",
xlab = "k")
plot(1:nk,apply(kmean_matrix, 2, min),
type = "b",
ylab = "wss",
xlab = "k")
kmean_seed2 <- seeds[which(kmean_matrix[,2]==min(kmean_matrix[,2]))[1]]
kmean_seed6 <- seeds[which(kmean_matrix[,6]==min(kmean_matrix[,6]))[1]]
set.seed(kmean_seed3)
kmean_seed2 <- seeds[which(kmean_matrix[,2]==min(kmean_matrix[,2]))[1]]
kmean_seed6 <- seeds[which(kmean_matrix[,6]==min(kmean_matrix[,6]))[1]]
set.seed(kmean_seed3)
set.seed(kmean_seed2)
means2 <- kmeans(dat_scaled, centers = 2)
set.seed(kmean_seed6)
means6 <- kmeans(dat_scaled, centers = 6)
means2$withinss
means6$withinss
plot(1:nk,apply(kmean_matrix, 2, min),
type = "l",
ylab = "wss",
xlab = "k")
clust2 <- cbind(dat[,1:3],cluster = means2$cluster,dat)
clust6 <- cbind(dat[,1:3],cluster = means6$cluster,dat)
clust2_map <- joinCountryData2Map(clust2, joinCode = "NAME", nameJoinColumn = "Country", )
clust2_map <- joinCountryData2Map(clust2, joinCode = "NAME",
nameJoinColumn = "Country",
verbose = T)
clust2_map <- joinCountryData2Map(clust2, joinCode = "NAME",
nameJoinColumn = "Country",
verbose = T)
knitr::opts_chunk$set(echo = TRUE)
library(sampling)
library(tidyverse)
library(rworldmap)
library(mclust)
dat <- read.csv("C:/Users/hadamul/OneDrive/Graduate school/Semester 4/Data Mining/Data-Mining-Final-Project/imputedData.csv")
dat_scaled <- scale(dat[,-1])
RNGkind (sample.kind = "Rounding")
set.seed(0)
nseeds <- 1000
nk <- 20
seeds <- ceiling(runif(nseeds,0,900000))
# kmean_matrix  <- matrix(NA, nrow = nseeds, ncol = nk)
#
# for (k in 1:nk) {
#   seed_iter = 0
#   for (s in seeds) {
#
#     set.seed(s)
#     seed_iter <- seed_iter + 1
#
#     kmean_matrix[seed_iter,k] <- kmeans(dat_scaled, centers = k)$tot.withinss
#   }
# }
# save(kmean_matrix, file = "kmean_matrix.RData")
load("kmean_matrix.RData")
plot(1:nk,apply(kmean_matrix, 2, min),
type = "l",
ylab = "wss",
xlab = "k")
kmean_seed2 <- seeds[which(kmean_matrix[,2]==min(kmean_matrix[,2]))[1]]
kmean_seed6 <- seeds[which(kmean_matrix[,6]==min(kmean_matrix[,6]))[1]]
set.seed(kmean_seed2)
means2 <- kmeans(dat_scaled, centers = 2)
set.seed(kmean_seed6)
means6 <- kmeans(dat_scaled, centers = 6)
means2$withinss
means6$withinss
clust2 <- cbind(dat[,1:3],cluster = means2$cluster,dat)
clust6 <- cbind(dat[,1:3],cluster = means6$cluster,dat)
clust2_map <- joinCountryData2Map(clust2, joinCode = "NAME",
nameJoinColumn = "Country",
verbose = T)
par(mar=c(0,0,1,0))
mapCountryData(mapToPlot = clust3_map,
nameColumnToPlot="cluster",
catMethod="categorical",
colourPalette = "rainbow")
mapCountryData(mapToPlot = clust2_map,
nameColumnToPlot="cluster",
catMethod="categorical",
colourPalette = "rainbow")
clust2_map <- joinCountryData2Map(clust2, joinCode = "NAME",
nameJoinColumn = "Country",
verbose = T)
par(mar=c(0,0,1,0))
mapCountryData(mapToPlot = clust2_map,
nameColumnToPlot="cluster",
catMethod="categorical",
colourPalette = "rainbow")
clust6_map <- joinCountryData2Map(clust6, joinCode = "NAME", nameJoinColumn = "Country")
clust6_map <- joinCountryData2Map(clust6, joinCode = "NAME", nameJoinColumn = "Country")
par(mar=c(0,0,1,0))
mapCountryData(mapToPlot = clust6_map,
nameColumnToPlot="cluster",
catMethod="categorical",
colourPalette = "rainbow")
mb_rep <- 20
mb_matrix <- matrix(NA, 14, mb_rep)
for (k in 1:mb_rep) {
mb_matrix[,k] <- Mclust(dat, k)$BIC
}
